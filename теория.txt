Микулич Алексей Эдуардович 10 группа Вариант 2

1) CreateThred, ExitThread, WaitForSingleObject, WaitForMultipleObject, Sleep, CreateEvent, SetEvent, ResetEvent, CloseHandle

2) Поток - объект ядра, которому операционная сиситема выделяет процессорное время для выполнения приложения.

3) Мьютекс — это объект синхронизации, предназначенный для обеспечения взаимного исключения доступа к разделяемым ресурсам. При использовании мьютекса только один поток может захватить его в определённый момент времени, что позволяет избежать конфликтов при обращении к общим данным или ресурсам. 

4) Событие — это объект синхронизации, используемый для уведомления одного или нескольких потоков о наступлении определённого состояния или события. События бывают двух типов:

Автоматический сброс (auto-reset) и Ручной сброс (manual-reset)

5) Поддержка многопоточности:
– В C++98 отсутствует стандартная поддержка потоков, что заставляло разработчиков прибегать к Win API или сторонним библиотекам для реализации параллельного выполнения.
– C++11 ввёл стандартные библиотеки для работы с потоками (std::thread, std::mutex, std::condition_variable), что упрощает написание кроссплатформенного многопоточного кода.

Управление ресурсами:
– В C++11 появились умные указатели (например, std::unique_ptr и std::shared_ptr), значительно облегчающие управление динамической памятью и уменьшающие вероятность утечек памяти.

Языковые улучшения:
– Введение лямбда-выражений упрощает передачу функциональных объектов и написание компактного кода, особенно при работе с алгоритмами и функциями обратного вызова.
– Автоматическое выведение типов (auto) позволяет сократить шаблонный код и улучшить читаемость.

Стандартная библиотека:
– Современные стандарты предоставляют более богатый набор алгоритмов и контейнеров, что позволяет писать более выразительный и оптимизированный код.

Общие вопросы:

1) Объектно-ориентированное программирование (ООП) – это парадигма программирования, в основе которой лежит концепция «объекта». Объект представляет собой совокупность данных (состояния) и методов (поведения), которые инкапсулируются в единый модуль. Основными принципами ООП являются:

Инкапсуляция: объединение данных и методов, работающих с ними, с сокрытием внутренних деталей реализации от внешнего мира.

Наследование: возможность создавать новые классы на основе существующих, расширяя или изменяя их функциональность.

Полиморфизм: способность объектов разных классов обрабатывать сообщения (вызывать методы) единообразным способом, что позволяет писать обобщённый и гибкий код.

Абстракция: выделение значимых характеристик объекта и сокрытие лишних деталей, что упрощает моделирование сложных систем.

Таким образом, ООП позволяет строить программное обеспечение в виде набора взаимодействующих объектов, что способствует повышению модульности, повторному использованию кода и облегчению сопровождения больших программных систем.

2) Магическое число 7 Миллера – примеры из IT
Магическое число 7 (±2) Миллера отражает ограниченность объёма кратковременной памяти человека. В IT эта концепция находит применение в проектировании интерфейсов, алгоритмов и структур данных. Примеры:

Меню навигации: Ограничение числа основных пунктов меню до 7–9 элементов для удобства восприятия.

Панель инструментов: Расположение не более 7–9 иконок, чтобы пользователь мог легко запомнить и найти нужные функции.

Структура вкладок в браузерах: Ограничение числа одновременно открытых вкладок в определённом наборе для улучшения ориентации пользователя.

Списки недавних документов: Ограничение числа отображаемых элементов, что облегчает быстрый выбор ранее открытых файлов.

Кнопки быстрого доступа в приложениях: Например, 7 основных горячих клавиш для часто используемых команд.

Мнемонические правила при проектировании UI: Использование числовых ограничений для упрощения запоминания последовательностей команд.

Количество шагов в мастерах настройки: Ограничение числа шагов процесса (например, 7 шагов) для уменьшения когнитивной нагрузки на пользователя.

3) Энтропия ПО и нег энтропийные меры
Энтропия ПО – это метафорическое понятие, характеризующее степень хаотичности и снижения структурированности в кодовой базе по мере её развития. Чем больше изменений и «спонтанных» доработок в проекте, тем выше энтропия, что приводит к ухудшению читаемости, увеличению числа ошибок и снижению поддержки системы.

Для борьбы с энтропией применяются меры, направленные на поддержание порядка и структурированности. Примеры нег энтропийных мер в разработке ПО:

Строгие coding standards: Определение и соблюдение единых правил оформления кода, что облегчает его чтение и сопровождение.

Автоматизированное тестирование: Покрытие функциональности тестами для своевременного обнаружения регрессий и ошибок.

Рефакторинг: Регулярное улучшение структуры кода без изменения внешнего поведения, что снижает сложность и повышает поддерживаемость.

Код-ревью: Систематическая проверка кода коллегами, позволяющая выявлять потенциальные проблемы и распространять лучшие практики.

Использование систем контроля версий: Отслеживание изменений в проекте, что позволяет управлять историей разработки и обеспечивать возможность отката к стабильным версиям.

4) 5 признаков сложной системы по Гради Бучу с примерами
Гради Буч (один из создателей объектно-ориентированного подхода) выделял характерные признаки сложных систем. Ниже приведены пять таких признаков с примерами, основанными на лабораторных работах и pet-проектах:

Иерархическая организация компонентов

Пример 1: В лабораторной работе по потокам выделение основного потока и дочерних потоков marker, где основной поток управляет синхронизацией и завершением работы дочерних.

Пример 2: В pet-проекте реализована архитектура с несколькими уровнями абстракции: от модуля доступа к данным до пользовательского интерфейса, что позволяет изолировать изменения в каждом уровне.

Сильная взаимозависимость и связи между компонентами

Пример 1: Лабораторная работа с потоками, где корректное функционирование системы зависит от точной синхронизации через события и мьютексы.

Пример 2: В pet-проекте модуль бизнес-логики тесно интегрирован с модулем обработки пользовательских запросов, что требует тщательного управления зависимостями для предотвращения ошибок.

Эмерджентное поведение

Пример 1: В лабораторной работе наблюдались неожиданные эффекты при взаимодействии нескольких потоков, когда изменения в одном потоке влияли на результаты работы другого.

Пример 2: В pet-проекте, реализующем обработку событий, сложное поведение системы проявлялось в результате совокупного влияния множества независимых событий, приводящих к неочевидным последствиям.

Невозможность полного предсказания всех сценариев

Пример 1: При разработке синхронных алгоритмов в лабораторной работе сложно было учесть все возможные состояния гонок и блокировок, что требовало дополнительных проверок.

Пример 2: В pet-проекте, связанном с обработкой реального времени, сложно было предсказать все варианты взаимодействия пользователя с системой, что приводило к необходимости адаптивных решений.

Постоянное изменение и развитие системы

Пример 1: Лабораторная работа по потокам демонстрировала, как добавление нового функционала (например, дополнительные сигналы для потоков) меняло логику работы существующей системы.

Пример 2: В pet-проекте постоянно появлялись новые требования от пользователей, что приводило к необходимости рефакторинга архитектуры для поддержки масштабируемости и гибкости.

5) Закон иерархических компенсаций Седова – исторические примеры
Закон иерархических компенсаций Седова описывает тенденцию, при которой сложность на одном уровне системы компенсируется введением иерархии и дополнительного уровня абстракции на другом. Исторические примеры применения данного закона в эволюции IT:

Архитектура ЭВМ:
Переход от монолитных вычислительных машин к многоуровневым архитектурам, где каждый уровень (железо, ОС, прикладное ПО) компенсирует ограничения предыдущего.

Модель OSI в сетевых протоколах:
Введение семислойной модели, где каждый уровень отвечает за свою часть коммуникационного процесса, позволяя компенсировать сложность прямой связи между конечными устройствами.

Клиент-серверная архитектура:
Разделение систем на клиентскую и серверную части, где серверы обрабатывают сложные задачи, а клиенты обеспечивают удобный интерфейс, компенсируя ограничения монолитного подхода.

Появление микросервисной архитектуры:
Замена монолитных приложений набором небольших сервисов, каждый из которых реализует отдельную бизнес-функцию, что позволяет легче масштабировать и обновлять систему.

Многоуровневая архитектура систем управления базами данных (СУБД):
Использование кэширования, индексации и транзакций на разных уровнях для повышения производительности и надёжности при увеличении объёма данных.